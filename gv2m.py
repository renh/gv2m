#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright Â© 2016 Hao Ren <renh.cn@gmail.com>
#
# Distributed under terms of the MIT license.

"""
Convert VASP OUTCAR generated by a geometry optimization
to molden format (http://www.cmbi.ru.nl/molden/molden_format.html).

Molden can then visualize the geometry convergence by extract the
energies, max forces, avg forces, max displacements, etc.
"""

from __future__ import absolute_import, division, print_function, unicode_literals
import argparse
import numpy as np

parser = argparse.ArgumentParser()
parser.add_argument('-o', '--outcar',
        help='VASP OUTCAR file (input)', default='OUTCAR')
parser.add_argument('-m', '--molden',
        help='Molden format output filename', default='gconv.molden')
parser.add_argument('-v', '--verbosity', action='store_true',
        help='increase output verbosity')
parser.add_argument('-s', '--skip', default=0,
        help='skip n records at head')
args = parser.parse_args()


class OUTCAR:
    def __init__(self, fname=args.outcar):
        try:
            self.__fh = open(fname, 'r')
            self.__fh.close()
        except IOError as err:
            print("Can not open file {}: {}".format(fname,err))
        self.__fname = fname
        self.__IonsPerType = self.getIonsPerType()
        self.__NIons = sum(self.__IonsPerType)
        self.__NTypes = len(self.__IonsPerType)
        self.__IonTypes = self.getIonTypes()
        self.__IonList = self.getIonList()
    def getIonsPerType(self):
        with open(self.__fname, 'r') as fh:
            while True:
                l = fh.readline()
                if l.startswith('   ions per type'):
                    break
        IonsPerType = [int(x) for x in l.split()[4:]]
        return IonsPerType

    def getIonTypes(self):
        types = []
        with open(self.__fname, 'r') as fh:
            while True:
                l = fh.readline()
                if l.startswith(' POTCAR'):
                    types.append(l.split()[2])
                    if len(types) == self.__NTypes:
                        break
        return types

    def getIonList(self):
        ionList = []
        for it in range(self.__NTypes):
            #print(self.__IonTypes[it], self.__IonsPerType[it])
            ionList += [self.__IonTypes[it]] * self.__IonsPerType[it]
        return ionList

    def getNSteps(self):
        nsteps = 0
        with open(self.__fname, 'r') as fh:
            l = fh.readline()
            while l:
                if l.startswith(' POSITION'):
                    nsteps += 1
                l = fh.readline()
        return nsteps

    def getStepInfo(self):
        nions = self.__NIons
        nsteps = self.getNSteps()
        coords_and_forces = np.zeros([nsteps, nions, 6])
        energies = np.zeros(nsteps)

        with open(self.__fname, 'r') as fh:
            iter = 0
            while iter < nsteps:
                while True:
                    l = fh.readline()
                    if l.startswith(' POSITION'):
                        break
                l = fh.readline()
                for i in range(nions):
                    l = fh.readline()
                    coords_and_forces[iter,i] = [float(x) for x in l.split()]
                while True:
                    l = fh.readline()
                    if l.startswith('  free  energy'):
                        break
                energies[iter] = float(l.split()[-2])
                iter += 1
        return (energies, coords_and_forces)

def write_molden_format(fname, ionList, energies, coords_and_forces):
    args.skip = int(args.skip)
    fh = open(fname, 'w')

    nsteps = len(energies)
    nions = len(coords_and_forces[0])
    # write headers
    fh.write('[Molden Format]\n[Title]\n\n')

    # write geometry convergence section
    fh.write('[GEOCONV]\nenergy\n')
    for e in energies[args.skip:]:
        fh.write('{}\n'.format(e))
    maxf = []
    rmsf = []
    for istep in range(nsteps):
        if istep < args.skip:
            continue
        forces = coords_and_forces[istep,:,3:]
        f_mag = np.sqrt(np.sum(forces * forces, axis=1))
        maxf.append(np.max(f_mag))
        rmsf.append(np.sum(f_mag)/nions)
        # print('@130')
    fh.write('max-force\n')
    for istep in range(nsteps-args.skip):
        fh.write('{}\n'.format(maxf[istep]))
    fh.write('rms-force\n')
    for istep in range(nsteps-args.skip):
        fh.write('{}\n'.format(rmsf[istep]))

    fh.write('[GEOMETRIES] XYZ\n')
    for istep in range(nsteps):
        if istep < args.skip:
            continue
        fh.write('{}\n\n'.format(nions))
        for iion in range(nions):
            fh.write('{:<4s}{:10.6f}{:10.6f}{:10.6f}\n'.format(
                ionList[iion], *(coords_and_forces[istep,iion,:3])
                ))
    fh.close()






if __name__ == '__main__':
    vo = OUTCAR()
    ionList = vo.getIonList()
    nsteps = vo.getNSteps()
    if args.verbosity:
        print('\n{} ion-steps found in your VASP OUTCAR file "{}"\n'.format(nsteps,
            args.outcar))
        print("Parsing OUTCAR", end=" ... ")
    energies, coords_and_forces = vo.getStepInfo()
    if args.verbosity:
        print("finished.\n")
        print("Generating Molden file", end=" ... ")

    write_molden_format(args.molden, ionList, energies, coords_and_forces)

    if args.verbosity:
        print("finished.")
        print("Succeed written Molden file {}".format(args.molden))

    #print(vo.getIonsPerType())
    #print(vo.getIonTypes())
    #print(vo.getIonList())
    #print(vo.getNSteps())
    #f1 = coords_and_forces[0,:,3:]
